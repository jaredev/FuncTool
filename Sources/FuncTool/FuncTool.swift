// MIT License. Copyright Charles Jared Jetsel 2025
import Foundation

@freestanding(expression)
public macro stringify<T>(_ value: T) -> String = #externalMacro(module: "FuncToolMacros", type: "StringifyMacro")

@freestanding(expression)
public macro evaluateString(_ s: String) -> () -> Any = #externalMacro(module: "FuncToolMacros", type: "EvaluateStringMacro")

@freestanding(expression)
public macro callFuncWithIndexedParams<T>(_ value: T) -> ([String]) -> Any = #externalMacro(module: "FuncToolMacros", type: "CallFuncWithIndexedParamsMacro")

public struct FuncToolParam
{
    let name: String
    let typeDesc: String
    let isRequired: Bool
    let description: String
    
    init(name: String, typeDesc: String, isRequired: Bool = true, description: String = "")
    {
        self.name = name
        self.typeDesc = typeDesc
        self.isRequired = isRequired
        self.description = description
    }
}

/// Converts a function's name and parameters into the Tool format for MLX LLM usage.
///
/// Note: This should be generated by the #tool() macro
public struct FuncTool: Copyable, CustomStringConvertible
{
    /// Name of the function this tool calls
    public let name: String
    
    /// A description of what the function does and how to use it
    public let usage: String
    
    /// An array of parameter descriptions
    public let parameters: [FuncToolParam]
    
    public var description: String
    {
        var desc: String = "\tName:\(name)\n"
        desc += "\tUsage:\(usage)\n"
        desc += "\tFunc: \(name)("
        
        for param in parameters
        {
            desc += "\(param.name): \(param.typeDesc), "
        }
        
        if !parameters.isEmpty
        {
            desc.removeLast(2)
        }
        
        desc += ")\n"
        return desc
    }
    
    /// A closure that executes the underlying function the tool wraps.
    /// - Parameters:
    ///     - args: An array of Any parameters. These are handed in order to parameters to the function. These _must_ be convertible to the parameter types!
    ///
    /// - Returns: The closure must return a string to send along the LLM, this means the underlying function's return type must be convertible to String!
    public let exec: (_ args: [String]) -> String
        
    public init(name: String, usage: String, parameters: [FuncToolParam], exec: @escaping (_ args: [String]) -> String)
    {
        self.name = name
        self.usage = usage
        self.parameters = parameters
        self.exec = exec
    }
    
    /// The specification of the tool to inform an LLM with
    ///
    /// See: `swift-transformers Tokenizer.swift ToolSpec`
    public func toolSpec() -> [String: any Sendable]
    {
        var spec: [String: any Sendable] = [:]
        //        var spec =
        //        [
        //            "type": "function",
        //            "function":
        //            [
        //                "name": "\(name)",
        //                "description": "Get the current weather in a given location",
        ////                "parameters": [
        ////                    "type": "object",
        ////                    "properties": [
        //////                        "location": [
        //////                            "type": "string",
        //////                            "description": "The city and state, e.g. San Francisco, CA",
        //////                        ] as [String: String],
        //////                        "unit": [
        //////                            "type": "string",
        //////                            "enum": ["celsius", "fahrenheit"],
        ////                        ] as [String: any Sendable],
        ////                    ] as [String: [String: any Sendable]],
        ////                    "required": [], //["location"],
        ////                ] as [String: any Sendable],
        //            ] as [String: any Sendable],
        //        ] as [String: any Sendable]
        //
        //        if parameters.count > 0
        //        {
        //            spec["function"]["parameters"]
        //                    [
        //                        "type": "object",
        //                        "properties": [],
        //                        "required": [], // names of required parameters
        //                    ] as [String: any Sendable]
        //                ])
        //        }
        //        for p in parameters
        //        {
        //            // @TODO: If parameter is enum, then do enum instead with options, must be rawValue convertible to String
        //            spec["function"]["parameters"]["properties"][p.name] =
        //            [
        //                "type": p.typeDesc,
        //                "description": p.description,
        //            ] as [String: String]
        //
        //            if p.isRequired
        //            {
        //                spec["function"]["parameters"]["required"].append(p.name)
        //            }
        //        }
                
        return spec
    }
}

/// Gets the TypeInfo string description of the provided function
/// Parameters:
///     function: A function
///
/// Returns: String representation such as "(Type) -> ReturnType"
@freestanding(expression)
public macro funcTypeString<T>(_ function: T) -> String = #externalMacro(module: "FuncToolMacros", type: "StringifyFunctionTypeMacro")

typealias FuncParamsAndReturnTypes = (paramTypes: [String], returnType: String)

@available(macOS 13.0, *)
func funcTypesToStrings<T>(_ function: T) -> FuncParamsAndReturnTypes
{
    let typeInfoStr = String(describing: type(of:function)) // Example (Type,Type) -> ReturnType (or not, doesn't work...)
    var paramTypes: [Substring]
    var finalParamTypes: [String] = []

    // Extract type info from string such as (Type, Type) -> ReturnType
    guard let returnRange = typeInfoStr.firstRange(of:"->") else
    {
        fatalError("FuncTool: A return type is required for all tool functions!")
    }
    let returnTypeStr = String(typeInfoStr.suffix(typeInfoStr.distance(from: returnRange.upperBound, to: typeInfoStr.endIndex)));

    if returnTypeStr.isEmpty || returnTypeStr == "Void"
    {
        fatalError("FuncTool: A return type is required for all tool functions! Input: \(function) with typeInfo: \(typeInfoStr)")
    }
    
    // Extract parameter types
    let startParenTypeRange = typeInfoStr.firstRange(of:"(")
    let endParenTypeRange = typeInfoStr.firstRange(of:")")
    
    if startParenTypeRange == nil || endParenTypeRange == nil
    {
        fatalError("funcTypesToStrings(): Could not find function parameters. Missing parentheses? Input: \(function) with typeInfo: \(typeInfoStr)")
    }
    else
    {
        let allParamTypesRange = startParenTypeRange!.upperBound..<endParenTypeRange!.lowerBound // between ( and )
        paramTypes = typeInfoStr[allParamTypesRange].split(separator: ",")
    }
    
    for paramType in paramTypes
    {
        finalParamTypes.append(String(paramType))
    }
    
    return (finalParamTypes, returnTypeStr)
}

typealias FuncDetails = (funcName: String, paramNames: [String], indexedCallString: String)

/// Extracts details of the function name, parameter names, and the function call string from a function
@available(macOS 13.0, *)
func detailsOfStringifiedFunction(_ stringifiedFunc: String, paramTypes: [String]) -> FuncDetails
{
    let funcInput = stringifiedFunc;//: String = #stringify(function) // @TODO: Fix, needs to take input
    var paramNames: [Substring]
    
    // Extract names from input to macro such as funcName(param:param:)
    let startParenRange = funcInput.firstRange(of:"(")
    let endParenRange = funcInput.firstRange(of:")")
            
    if startParenRange == nil || endParenRange == nil
    {
        fatalError("@FuncTool: Could not find function parameters. Missing parentheses?")
    }
    
    var name = String(funcInput[...startParenRange!.lowerBound])
    name.removeLast() // trailing ')'

    let allParamNamesRange = startParenRange!.upperBound..<endParenRange!.lowerBound // between ( and )
    paramNames = funcInput[allParamNamesRange].split(separator: ":")
        
    let funcParts = funcInput.split(separator: ":") // Example: foo(x:y:) -> ["foo(x", "y", ")"]
    var callWithIndexedParams: String = ""
    var idx: Int = 0
    
    // @TODO: Remove, used elsewhere similarly
    // Insert parameter values by index yields something like "foo(x:args[0], y:args[1])"
    for part in funcParts
    {
        if (part != ")")
        {
            callWithIndexedParams += part + ":args[\(idx)] as \(paramTypes[idx]),"
            idx += 1
        }
        else
        {
            callWithIndexedParams.removeLast() // trailing ','
            callWithIndexedParams += part; // Closing ')'
        }
    }
    
    var finalParamNames : [String] = []
    
    for paramName in paramNames
    {
        finalParamNames.append(String(paramName).trimmingCharacters(in: CharacterSet.whitespaces))
    }
    
    return (String(name), finalParamNames, callWithIndexedParams)
}

@available(macOS 13.0, *)
public func makeTool<T>(_ function: T, stringifiedFunc: String, internalExec: @escaping ([String]) -> Any, usage: String = "") -> FuncTool
{
    let (paramTypes, _) = funcTypesToStrings(function)
    let (name, paramNames, callWithIndexedParams) = detailsOfStringifiedFunction(stringifiedFunc, paramTypes: paramTypes)
    
    if paramNames.count != paramTypes.count
    {
        fatalError("FuncTool: Parameter type and name mismatch!")
    }
    
    var params : [FuncToolParam] = []
    
    for (idx, paramName) in paramNames.enumerated()
    {
        params.append(FuncToolParam.init(name: paramName, typeDesc: paramTypes[idx]))
    }
        
    return FuncTool(name:name, usage: usage, parameters: params, exec:
    {
        args in
        
        do
        {
            if params.count != args.count
            {
                return "Observation: Error using tool named '\(name)'. The tool '\(name)' expects \(params.count) arguments, but \(args.count) were given."
            }
            
            let result = internalExec(args)
            return "Observation: the tool '\(name)' returned: \(result)"
        }
        catch
        {
            print(error)
        }
    })
}

@freestanding(expression)
public macro tool<T>(_ function: T) -> FuncTool = #externalMacro(module: "FuncToolMacros", type: "MakeToolMacro")

public struct ToolRegistry: CustomStringConvertible
{
    
    public typealias ToolResponse = String
    var tools: [String: FuncTool] = [:]
    
    public init(withTools: FuncTool...)
    {
        for tool in withTools
        {
            tools[tool.name] = tool
        }
    }

    public mutating func register(_ tools: FuncTool...)
    {
        for tool in tools
        {
            self.tools[tool.name] = tool
        }
    }
    
    public func call(_ toolNamed: String, withParams: [String]) -> ToolResponse
    {
        if let tool = tools[toolNamed]
        {
            return tool.exec(withParams)
        }
        else
        {
            return "Observation: Error. No tool named '\(toolNamed)' found in the tools registry.\n"
        }
    }
    
    public func call(withJSON: String) -> ToolResponse
    {
        return "FINISH ME"
    }
    
    public var description: String
    {
        var desc = "\n"
        
        for tool in tools
        {
            desc += "\(tool.value)\n"
        }
        return desc
    }

}
